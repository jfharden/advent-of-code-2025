;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                   228 colour clocks
;;    <------------------------------------------------>
;;
;;    |================================================|
;;    |            VERTICAL SYNC                       | 3 x VSYNC scanlines
;;    |================================================|
;;    |                                                |
;;    |                                                |
;;    |            VERTICAL BLANK                      | 37 x VBLANK scanlines
;;    |                                                |
;;    |                                                |
;;    |================================================|
;;    |            |                                   |
;;    |            |                                   |
;;    |   HORIZ.   |                                   | 192 x Visible area (NTSC)
;;    |   BLANK    |                                   |       scanlines
;;    |            |                                   |
;;    | <--------> | <-------------------------------> | 242 x Visible area (PAL)
;;    | 68 colour  |        160 colour clocks          |       scanlines
;;    |  clocks    |                                   |
;;    |            |                                   |
;;    |            |                                   |
;;    |            |                                   |
;;    |================================================|
;;    |                                                |
;;    |                                                | 30 x OVERSCAN scanlines
;;    |                                                |
;;    |================================================|
;;
;;    <------------------------------------------------>
;;                      76 CPU cycles
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  processor 6502

  include "includes/vcs.h"
  include "includes/macro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some useful macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  MAC SET_NUMBER_POINTER_TO_X ; Set X register to the number to display 0-9
    lda NumbersHighByte,X
    sta NumberPointer
    lda NumbersLowByte,X
    sta NumberPointer+1
  ENDM

  MAC NEXT_SCANLINE
    dec ScanlineNumber
    sta WSYNC
  ENDM

  MAC INC_TOTAL_TIMES_ON_ZERO
    ; Takes between 15 and 53 cycles depending how many bytes overflow when added
                            ; CYCLES - RUNNING TOTAL - Note
    sed                     ; 2     -  2 - Set binary coded decimal addition
    clc                     ; 2     -  3 - Clear the carry flag
    lda TotalTimesOnZero+3  ; 3     -  5 - Load the least significant byte into A
    adc #1                  ; 2     -  7 - Add 1 to the least significant byte
    sta TotalTimesOnZero+3  ; 3     - 10 - Store the result
    bcc IncComplete         ; 2 + 1 - 13 - If there was no overflow (no carry flag) then we are done

    clc                     ; 2     - 15 - Clear the carry flag
    lda TotalTimesOnZero+2  ; 3     - 17 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                  ; 2     - 19
    sta TotalTimesOnZero+2  ; 3     - 22 - Store the result
    bcc IncComplete         ; 2 + 1 - 25 - If there was no overflow (no carry flag) we are done

    clc                     ; 2     - 27 - Clear the carry flag
    lda TotalTimesOnZero+1  ; 3     - 30 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                  ; 2     - 32 -
    sta TotalTimesOnZero+1  ; 3     - 35 - Store the result
    bcc IncComplete         ; 2 + 1 - 38 - If there was no overflow (no carry flag) we are done

    clc                     ; 2     - 40 - Clear the carry flag
    lda TotalTimesOnZero    ; 3     - 43 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                  ; 2     - 45 -
    sta TotalTimesOnZero    ; 3     - 48 - Store the result
    bcc IncComplete         ; 2 + 1 - 51 - If there was no overflow (no carry flag) we are done
                            ; If there was an overflow.....oops, we exceeded our max of 8 digits
IncComplete:
    cld                     ; 2      - 15 / 27 / 40 / 53 - Disable binary coded decimal addition
  ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define variables for use in RAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  seg.u Variables
  org $80

ScanlineNumber   byte ; Allocate 1 byte to store the current scanline number
NumberHeight     byte ; Allocate 1 byte to store the height of the number
NumberPointer    ds 2 ; Allocate enough space to store the address of a memory location
TotalTimesOnZero ds 4 ; Allocate space to store total times on zero
Temp             ds 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Start the ROM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  seg code
  org $F000

Start:
  CLEAN_START
  lda #$0E
  sta COLUP0  ; Set the colour of the player 1 bitmap to white
  lda #$00
  sta COLUBK  ; Set the background colour to black
  lda #11
  sta NumberHeight

  sed                    ; Set to binary coded decimal maths
  lda #0
  sta TotalTimesOnZero
  lda #0
  sta TotalTimesOnZero+1
  lda #0
  sta TotalTimesOnZero+2
  lda #0
  sta TotalTimesOnZero+3
  cld                    ; Unset binary coded decimal maths

NextFrame:
  ;; Set register a to value 2
  lda #2
  ;; Store value of register a (#2) to the TIA VBLANK to enable the VBLANK
  sta VBLANK
  ;; Store value of register a (#2) to the TIA VSYNC memory address to enable VSYNC
  sta VSYNC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate the 3 lines of empty VSYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  INC_TOTAL_TIMES_ON_ZERO
  REPEAT 3
    sta WSYNC
  REPEND

  lda #0
  sta VSYNC   ; We have now rendered the VSYNC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate the 37 lines of VBLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ldx #37
LoopVBlank:
  sta WSYNC   ; Set WSYNC to force the cpu to wait for the end of the current VBLANK line
  dex
  bne LoopVBlank

  stx VBLANK  ; Disable VBLANK (x is currently 0 from the loop above)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Draw the play field
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  lda #242
  sta ScanlineNumber

LoopVisible:
  lda #0

PrintNextTwoNumbers:
  pha                  ; Push the accumulator, which represents the byte offset for the number of times on zero
  tay                  ; Transfer the accumulator to Y so we can use it as a byte offset to LDA
  lda TotalTimesOnZero,Y
  pha                  ; push the accumulator onto the stack, we will need it again soon
  lsr                  ; Shift left 4 times to make the high nibble the low nibble
  lsr
  lsr
  lsr
  tax                  ; Put the accumulator into X ready for setting the number pointer

  SET_NUMBER_POINTER_TO_X
  jsr PrintNumber

  REPEAT 5
    NEXT_SCANLINE
  REPEND

  pla                 ; Pop the stack into the accumulator
  and #$0f            ; Mask so we only have the low nibble
  tax                 ; Put the accumulator into X ready for setting the number pointer
  SET_NUMBER_POINTER_TO_X
  jsr PrintNumber

  REPEAT 5
    NEXT_SCANLINE
  REPEND

  pla                 ; Pop the stack into the accumulator, this is the previously pushed byte offset for our total times on zero number
  clc
  adc #1              ; Increment the accumulator so we move onto the next byte in the total times on zero number
  cmp #4
  bne PrintNextTwoNumbers



ScanToEndOfVisible:
  NEXT_SCANLINE
  bne ScanToEndOfVisible

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Draw the Overscan - turn on vertical blank first
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  lda #2
  sta VBLANK

  ldx #30
LoopOverscan:
  sta WSYNC
  dex
  bne LoopOverscan

  jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Print a single number to the screen over 7 lines
;; Registers:
;;   y: Memory location of the number to render
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PrintNumber:
  NEXT_SCANLINE
  ldy #0

LoopNumber:
  lda (NumberPointer),Y    ; Load the byte of the bitmap into the accumulator
  sta GRP0                 ; Store the accumulator in the graphics register for player 0

  NEXT_SCANLINE

  iny                      ; Increment the y register which is counting if we are at the end of the bitmap

  cpy NumberHeight         ; Compare y to see if it has reached the bitmap height
  bne LoopNumber           ; Go to the next line

  lda #0
  sta GRP0                 ; Change to drawing a blank line

  rts                      ; return to the caller

NumbersHighByte:
  byte #<Number0
  byte #<Number1
  byte #<Number2
  byte #<Number3
  byte #<Number4
  byte #<Number5
  byte #<Number6
  byte #<Number7
  byte #<Number8
  byte #<Number9

NumbersLowByte:
  byte #>Number0
  byte #>Number1
  byte #>Number2
  byte #>Number3
  byte #>Number4
  byte #>Number5
  byte #>Number6
  byte #>Number7
  byte #>Number8
  byte #>Number9

Number0:
  byte #%01111110 ;  ######
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%01111110 ;  ######

Number1:
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number2:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########

Number3:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########

Number4:
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number5:
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########

Number6:
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########

Number7:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number8:
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########

Number9:
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill ROM to 4KB and set reset and interrupt vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  org $FFFC
  .word Start
  .word Start
