;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;                   228 colour clocks
;;    <------------------------------------------------>
;;
;;    |================================================|
;;    |            VERTICAL SYNC                       | 3 x VSYNC scanlines
;;    |================================================|
;;    |                                                |
;;    |                                                |
;;    |            VERTICAL BLANK                      | 37 x VBLANK scanlines
;;    |                                                |
;;    |                                                |
;;    |================================================|
;;    |            |                                   |
;;    |            |                                   |
;;    |   HORIZ.   |                                   | 192 x Visible area (NTSC)
;;    |   BLANK    |                                   |       scanlines
;;    |            |                                   |
;;    | <--------> | <-------------------------------> | 242 x Visible area (PAL)
;;    | 68 colour  |        160 colour clocks          |       scanlines
;;    |  clocks    |                                   |
;;    |            |                                   |
;;    |            |                                   |
;;    |            |                                   |
;;    |================================================|
;;    |                                                |
;;    |                                                | 30 x OVERSCAN scanlines
;;    |                                                |
;;    |================================================|
;;
;;    <------------------------------------------------>
;;                      76 CPU cycles
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  processor 6502

  include "includes/vcs.h"
  include "includes/macro.h"
  include "includes/input.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some useful macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; Takes 14 cycles
  MAC SET_NUMBER_POINTER_TO_X ; Set X register to the number to display 0-9
                            ; Cycles - Total - Notes
    lda NumbersHighByte,X   ; 4      - 4
    sta NumberPointer       ; 3      - 7
    lda NumbersLowByte,X    ; 4      - 11
    sta NumberPointer+1     ; 3      - 14
  ENDM

  ; Takes 7 cycles
  MAC NEXT_SCANLINE
                            ; Cycles - Total - Notes
    sta WSYNC               ; 2      - 2
    dec ScanlineNumber      ; 5      - 7
  ENDM

  ; Takes 24 cycles
  MAC INC_INPUT_POINTER
                                    ; Cycles - Total  - Notes
    clc                             ; 2      - 2
    lda CurrentInputPosPointer      ; 3      - 5
    adc IncrementBy                 ; 3      - 8
    sta CurrentInputPosPointer      ; 3      - 11
    bcc .IncrementFinished          ; 2+1    - 14

    clc                             ; 2      - 16
    lda CurrentInputPosPointer+1    ; 3      - 19
    adc #1                          ; 2      - 21
    sta CurrentInputPosPointer+1    ; 3      - 24
    ; If it overflows we are kaput!
.IncrementFinished
  ENDM

  ; Takes from 10 to 66 cycles
  MAC ADD_WHOLE_ROTATIONS

    lda NotchesToMove           ; 3        - 3
    sec                         ; 2        - 5
    sbc #48                     ; 2        - 7        - Subtract 48 from the ascii value to get the corrent binary number
    bmi .WholeRotationsFinished ; 2 + 1    - 9/10     - If it's negative then it was binary 0 meaning no digit
    sta IncrementBy             ; 3        - 12       - Set up LANDED_ON_ZERO to add the number of hundreds

    LANDED_ON_ZERO              ; 16 to 54 - 28 to 66
.WholeRotationsFinished:
  ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Define variables for use in RAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  seg.u Variables
  org $80

ScanlineNumber          byte ; Allocate 1 byte to store the current scanline number
NumberHeight            byte ; Allocate 1 byte to store the height of the number
NumberPointer           ds 2 ; Allocate enough space to store the address of a memory location
TotalTimesOnZero        ds 4 ; Allocate space to store total times on zero
CurrentInputPosPointer  ds 2 ; Allocate enough space to store a pointer to the current position in the puzzle input
Direction               byte ; Allocate 1 byte to store the direction (L or R)
NotchesToMove           ds 3 ; Allocate enough bytes to store 3 digits for rotation
CurrentPosition         byte ; Allocate space for the current position of the dial
Complete                byte ; Allocate space for a flag saying that processing the input is complete
IncrementBy             byte ; Allocate space for a variable to store how much to incremnet something by (used by multiple macros)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Start the ROM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  seg code
  org $F000

Start:
  CLEAN_START
  lda #$0E
  sta COLUP0  ; Set the colour of the player 1 bitmap to white
  lda #$00
  sta COLUBK  ; Set the background colour to black
  lda #11
  sta NumberHeight
  lda #50
  sta CurrentPosition

  lda #<PuzzleInput
  sta CurrentInputPosPointer
  lda #>PuzzleInput
  sta CurrentInputPosPointer+1

  lda #0
  sta TotalTimesOnZero
  sta TotalTimesOnZero+1
  sta TotalTimesOnZero+2
  sta TotalTimesOnZero+3
  sta Complete

NextFrame:
  ;; Set register a to value 2
  lda #2
  ;; Store value of register a (#2) to the TIA VBLANK to enable the VBLANK
  sta VBLANK
  ;; Store value of register a (#2) to the TIA VSYNC memory address to enable VSYNC
  sta VSYNC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate the 3 lines of empty VSYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  REPEAT 3
    sta WSYNC
  REPEND

  lda #0
  sta VSYNC   ; We have now rendered the VSYNC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generate the 37 lines of VBLANK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  lda #37                           ; 2   - 2
  sta ScanlineNumber                ; 3   - 5

  lda Complete                      ; 3   - 8
  cmp #1                            ; 2   - 10
  bne ReadNextLine                  ; 2+1 - 12/13
  jmp LoopVBlank                    ; 3   - 15

ReadNextLine:
  ; Zero out the number of notches to move
  lda #0                            ; 2   - 17
  sta NotchesToMove                 ; 3   - 20
  sta NotchesToMove+1               ; 3   - 23
  sta NotchesToMove+2               ; 3   - 26

  ; Read the next line of puzzle input
  ldy #0                            ; 2   - 28

  ; Read the direction (if it's a binary 0 then we have reached the end of the puzzlue input)
  lda (CurrentInputPosPointer),Y    ; 4   - 32
  cmp #0                            ; 2   - 34
  bne Incomplete                    ; 2+1 - 36/37
  lda #1                            ; 2   - 39
  sta Complete                      ; 3   - 43
  jmp LoopVBlank                    ; 3   - 46

Incomplete:
  sta Direction                     ; 3   - 49
  NEXT_SCANLINE  ; 2 previous scanline, 5 next scanline

; Loop takes between 25 and 51 PLUS the NEXT_SCANLINE extra 5 above, so 30 and 56
FindEndOfNumber:
  ; Read forward until we hit binary 0 to signify the end of the number
  iny                               ; 2   - 2
  lda (CurrentInputPosPointer),Y    ; 6   - 8 -Load the character at the new read position
  cmp #0                            ; 2   - 10
  bne FindEndOfNumber               ; 2+1 - 12/13

  ; This is a VERY unsafe assumption that there can't be more than 3 digits in the input line
  ; But there isn't in mine, so it will do
  tya                               ; 2   -  2 - We need to know how many digits there were later so copy Y into A
  pha                               ; 3   -  5 - and push it onto the stack
  dey                               ; 2   -  7 - Y is currently pointing to the nil byte, move it to the last digit

  ldx #2                            ; 2   -  9
  ; Total cycles in worst case is 5 from NEXT SCANLINE + 56 from Loop + 9 from above + 2 from following NEXT_SCANLINE = 72

  NEXT_SCANLINE  ; 2 previous scanline, 5 next scanline - Next loop max time needs entire scanline with no wiggle room
; Loop takes between 33 (single digit) and 77 (3 digits)
ReadNumber:
  lda (CurrentInputPosPointer),Y    ; 6   - 6     - Load the character at the new read position
  cmp #58                           ; 2   - 8     - Compare against the first ASCII binary value after the numbers. If we have reached it then the whole number has been read
  bpl NumberReadComplete            ; 2+1 - 10/11 -
  dey                               ; 2   - 12    - Move read (and storage) position back 1
  sta NotchesToMove,X               ; 5   - 17
  dex                               ; 2   - 19
  jmp ReadNumber                    ; 3   - 22

NumberReadComplete:
  cpx #$FF ; If we iterated 3 times we need to SKIP a scanline
  bne NumberReadCompleteWithTwoOrFewerDigits
  dec ScanlineNumber
  jmp NumberReadCompleteWithThreeDigits

NumberReadCompleteWithTwoOrFewerDigits:
  NEXT_SCANLINE         ; 2 previous scanline, 5 next scanline

NumberReadCompleteWithThreeDigits:
  pla                   ; 3   - 3
  clc                   ; 2   - 5
  adc #1                ; 2   - 7
  sta IncrementBy       ; 3   - 10  - The stack had the number of digits + 1 (it was pointing to the null terminator) in it stored earlier (prior to ReadNumber)
  INC_INPUT_POINTER     ; 24  - 34

  NEXT_SCANLINE         ; 2 previous scanline, 5 next scanline

  ; Direction doesn't matter, add whole rotations
  ADD_WHOLE_ROTATIONS   ; 10 to 66

  NEXT_SCANLINE         ; 2 previous scanline, 5 next scanline

  ; Left or right
  lda Direction
  cmp #$4c        ; L in ascii
  beq LeftTurn

  cmp #$52        ; R in ascii
  beq RightTurn

; TODO - Turn the number of notches that has been read, not just the whole rotations
LeftTurn:

; TODO - Turn the number of notches that has been read, not just the whole rotations
RightTurn:

LoopVBlank:
  NEXT_SCANLINE  ; 2 previous scanline, 5 next scanline
  bne LoopVBlank ; 3

  ldx #0          ; 2
  stx VBLANK      ; 3 Disable VBLANK (x is currently 0 from the loop above)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Draw the play field
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  lda #242
  sta ScanlineNumber

LoopVisible:
  lda #0

PrintNextTwoNumbers:
  pha                  ; Push the accumulator, which represents the byte offset for the number of times on zero
  tay                  ; Transfer the accumulator to Y so we can use it as a byte offset to LDA
  lda TotalTimesOnZero,Y
  pha                  ; push the accumulator onto the stack, we will need it again soon
  lsr                  ; Shift left 4 times to make the high nibble the low nibble
  lsr
  lsr
  lsr
  tax                  ; Put the accumulator into X ready for setting the number pointer

  SET_NUMBER_POINTER_TO_X
  jsr PrintNumber

  REPEAT 5
    NEXT_SCANLINE      ; 2 previous scanline, 5 next scanline
  REPEND

  pla                 ; Pop the stack into the accumulator
  and #$0f            ; Mask so we only have the low nibble
  tax                 ; Put the accumulator into X ready for setting the number pointer
  SET_NUMBER_POINTER_TO_X
  jsr PrintNumber

  REPEAT 5
    NEXT_SCANLINE     ; 2 previous scanline, 5 next scanline
  REPEND

  pla                 ; Pop the stack into the accumulator, this is the previously pushed byte offset for our total times on zero number
  clc
  adc #1              ; Increment the accumulator so we move onto the next byte in the total times on zero number
  cmp #4
  bne PrintNextTwoNumbers



ScanToEndOfVisible:
  NEXT_SCANLINE           ; 2 previous scanline, 5 next scanline
  bne ScanToEndOfVisible  ; 2+1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Draw the Overscan - turn on vertical blank first
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  lda #2
  sta VBLANK

  ldx #30
LoopOverscan:
  sta WSYNC
  dex
  bne LoopOverscan

  jmp NextFrame

  ; Takes between 16 and 54 cycles depending how many bytes overflow when added
  MAC LANDED_ON_ZERO
                                ; CYCLES - RUNNING TOTAL - Note
    sed                         ; 2     -  2 - Set binary coded decimal addition
    clc                         ; 2     -  3 - Clear the carry flag
    lda TotalTimesOnZero+3      ; 3     -  5 - Load the least significant byte into A
    adc IncrementBy             ; 3     -  8
    sta TotalTimesOnZero+3      ; 3     - 11 - Store the result
    bcc .IncComplete            ; 2 + 1 - 14 - If there was no overflow (no carry flag) then we are done

    clc                         ; 2     - 16 - Clear the carry flag
    lda TotalTimesOnZero+2      ; 3     - 18 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                      ; 2     - 20
    sta TotalTimesOnZero+2      ; 3     - 23 - Store the result
    bcc .IncComplete            ; 2 + 1 - 26 - If there was no overflow (no carry flag) we are done

    clc                         ; 2     - 28 - Clear the carry flag
    lda TotalTimesOnZero+1      ; 3     - 31 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                      ; 2     - 33 -
    sta TotalTimesOnZero+1      ; 3     - 36 - Store the result
    bcc .IncComplete            ; 2 + 1 - 39 - If there was no overflow (no carry flag) we are done

    clc                         ; 2     - 41 - Clear the carry flag
    lda TotalTimesOnZero        ; 3     - 44 - Given there was overflow, carry the addition to the next least significant byte
    adc #1                      ; 2     - 46 -
    sta TotalTimesOnZero        ; 3     - 49 - Store the result
    bcc .IncComplete            ; 2 + 1 - 52 - If there was no overflow (no carry flag) we are done
                                ; If there was an overflow.....oops, we exceeded our max of 8 digits
.IncComplete:
    cld                         ; 2      - 16 / 28 / 41 / 54 - Disable binary coded decimal addition
  ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Print a single number to the screen over 7 lines
;; Registers:
;;   y: Memory location of the number to render
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PrintNumber:
  NEXT_SCANLINE
  ldy #0

LoopNumber:
  lda (NumberPointer),Y    ; Load the byte of the bitmap into the accumulator
  sta GRP0                 ; Store the accumulator in the graphics register for player 0

  NEXT_SCANLINE

  iny                      ; Increment the y register which is counting if we are at the end of the bitmap

  cpy NumberHeight         ; Compare y to see if it has reached the bitmap height
  bne LoopNumber           ; Go to the next line

  lda #0
  sta GRP0                 ; Change to drawing a blank line

  rts                      ; return to the caller

NumbersHighByte:
  byte #<Number0
  byte #<Number1
  byte #<Number2
  byte #<Number3
  byte #<Number4
  byte #<Number5
  byte #<Number6
  byte #<Number7
  byte #<Number8
  byte #<Number9

NumbersLowByte:
  byte #>Number0
  byte #>Number1
  byte #>Number2
  byte #>Number3
  byte #>Number4
  byte #>Number5
  byte #>Number6
  byte #>Number7
  byte #>Number8
  byte #>Number9

Number0:
  byte #%01111110 ;  ######
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%01111110 ;  ######

Number1:
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number2:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########

Number3:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########

Number4:
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number5:
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########

Number6:
  byte #%11111111 ; ########
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%10000000 ; #
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########

Number7:
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #

Number8:
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########

Number9:
  byte #%11111111 ; ########
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%10000001 ; #      #
  byte #%11111111 ; ########
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%00000001 ;        #
  byte #%11111111 ; ########


PuzzleInput:
  PUZZLE_INPUT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill ROM to 4KB and set reset and interrupt vectors
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  org $FFFC
  .word Start
  .word Start
